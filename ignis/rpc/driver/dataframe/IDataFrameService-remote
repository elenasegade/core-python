#!/usr/bin/env python
#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

import sys
import pprint
if sys.version_info[0] > 2:
    from urllib.parse import urlparse
else:
    from urlparse import urlparse
from thrift.transport import TTransport, TSocket, TSSLSocket, THttpClient
from thrift.protocol.TBinaryProtocol import TBinaryProtocol

from ignis.rpc.driver.dataframe import IDataFrameService
from ignis.rpc.driver.dataframe.ttypes import *

if len(sys.argv) <= 1 or sys.argv[1] == '--help':
    print('')
    print('Usage: ' + sys.argv[0] + ' [-h host[:port]] [-u url] [-f[ramed]] [-s[sl]] [-novalidate] [-ca_certs certs] [-keyfile keyfile] [-certfile certfile] function [arg1 [arg2...]]')
    print('')
    print('Functions:')
    print('  void setName(IDataFrameId id, string name)')
    print('  void persist(IDataFrameId id, i8 level)')
    print('  void cache(IDataFrameId id)')
    print('  void unpersist(IDataFrameId id)')
    print('  void uncache(IDataFrameId id)')
    print('  IDataFrameId repartition(IDataFrameId id, i64 numPartitions)')
    print('  IDataFrameId coalesce(IDataFrameId id, i64 numPartitions, bool shuffle)')
    print('  i64 partitions(IDataFrameId id)')
    print('  void saveAsObjectFile(IDataFrameId id, string path, i8 compression)')
    print('  void saveAsTextFile(IDataFrameId id, string path)')
    print('  void saveAsJsonFile(IDataFrameId id, string path, bool pretty)')
    print('  IDataFrameId map_(IDataFrameId id, ISource src)')
    print('  IDataFrameId filter(IDataFrameId id, ISource src)')
    print('  IDataFrameId flatmap(IDataFrameId id, ISource src)')
    print('  IDataFrameId mapPartitions(IDataFrameId id, ISource src, bool preservesPartitioning)')
    print('  IDataFrameId mapPartitionsWithIndex(IDataFrameId id, ISource src, bool preservesPartitioning)')
    print('  IDataFrameId applyPartition(IDataFrameId id, ISource src)')
    print('  IDataFrameId groupBy(IDataFrameId id, ISource src)')
    print('  IDataFrameId groupBy2(IDataFrameId id, ISource src, i64 numPartitions)')
    print('  IDataFrameId sort(IDataFrameId id, bool ascending)')
    print('  IDataFrameId sort2(IDataFrameId id, bool ascending, i64 numPartitions)')
    print('  IDataFrameId sortBy(IDataFrameId id, ISource src, bool ascending)')
    print('  IDataFrameId sortBy3(IDataFrameId id, ISource src, bool ascending, i64 numPartitions)')
    print('  i64 reduce(IDataFrameId id, ISource src, ISource tp)')
    print('  i64 treeReduce(IDataFrameId id, ISource src, ISource tp)')
    print('  i64 treeReduce4(IDataFrameId id, ISource src, i64 depth, ISource tp)')
    print('  i64 collect(IDataFrameId id, ISource tp)')
    print('  i64 aggregate(IDataFrameId id, ISource seqOp, ISource combOp, ISource tp)')
    print('  i64 treeAggregate(IDataFrameId id, ISource seqOp, ISource combOp, ISource tp)')
    print('  i64 treeAggregate5(IDataFrameId id, ISource seqOp, ISource combOp, i64 depth, ISource tp)')
    print('  i64 fold(IDataFrameId id, ISource src, ISource tp)')
    print('  i64 take(IDataFrameId id, i64 num, ISource tp)')
    print('  void foreach_(IDataFrameId id, ISource src)')
    print('  void foreachPartition(IDataFrameId id, ISource src)')
    print('  i64 top(IDataFrameId id, i64 num, ISource tp)')
    print('  i64 top4(IDataFrameId id, i64 num, ISource cmp, ISource tp)')
    print('  IDataFrameId sample(IDataFrameId id, bool withReplacement, double fraction, i32 seed)')
    print('  i64 takeSample(IDataFrameId id, bool withReplacement, i64 num, i32 seed, ISource tp)')
    print('  i64 count(IDataFrameId id)')
    print('  i64 max(IDataFrameId id, ISource cmp, ISource tp)')
    print('  i64 min(IDataFrameId id, ISource cmp, ISource tp)')
    print('')
    sys.exit(0)

pp = pprint.PrettyPrinter(indent=2)
host = 'localhost'
port = 9090
uri = ''
framed = False
ssl = False
validate = True
ca_certs = None
keyfile = None
certfile = None
http = False
argi = 1

if sys.argv[argi] == '-h':
    parts = sys.argv[argi + 1].split(':')
    host = parts[0]
    if len(parts) > 1:
        port = int(parts[1])
    argi += 2

if sys.argv[argi] == '-u':
    url = urlparse(sys.argv[argi + 1])
    parts = url[1].split(':')
    host = parts[0]
    if len(parts) > 1:
        port = int(parts[1])
    else:
        port = 80
    uri = url[2]
    if url[4]:
        uri += '?%s' % url[4]
    http = True
    argi += 2

if sys.argv[argi] == '-f' or sys.argv[argi] == '-framed':
    framed = True
    argi += 1

if sys.argv[argi] == '-s' or sys.argv[argi] == '-ssl':
    ssl = True
    argi += 1

if sys.argv[argi] == '-novalidate':
    validate = False
    argi += 1

if sys.argv[argi] == '-ca_certs':
    ca_certs = sys.argv[argi+1]
    argi += 2

if sys.argv[argi] == '-keyfile':
    keyfile = sys.argv[argi+1]
    argi += 2

if sys.argv[argi] == '-certfile':
    certfile = sys.argv[argi+1]
    argi += 2

cmd = sys.argv[argi]
args = sys.argv[argi + 1:]

if http:
    transport = THttpClient.THttpClient(host, port, uri)
else:
    if ssl:
        socket = TSSLSocket.TSSLSocket(host, port, validate=validate, ca_certs=ca_certs, keyfile=keyfile, certfile=certfile)
    else:
        socket = TSocket.TSocket(host, port)
    if framed:
        transport = TTransport.TFramedTransport(socket)
    else:
        transport = TTransport.TBufferedTransport(socket)
protocol = TBinaryProtocol(transport)
client = IDataFrameService.Client(protocol)
transport.open()

if cmd == 'setName':
    if len(args) != 2:
        print('setName requires 2 args')
        sys.exit(1)
    pp.pprint(client.setName(eval(args[0]), args[1],))

elif cmd == 'persist':
    if len(args) != 2:
        print('persist requires 2 args')
        sys.exit(1)
    pp.pprint(client.persist(eval(args[0]), eval(args[1]),))

elif cmd == 'cache':
    if len(args) != 1:
        print('cache requires 1 args')
        sys.exit(1)
    pp.pprint(client.cache(eval(args[0]),))

elif cmd == 'unpersist':
    if len(args) != 1:
        print('unpersist requires 1 args')
        sys.exit(1)
    pp.pprint(client.unpersist(eval(args[0]),))

elif cmd == 'uncache':
    if len(args) != 1:
        print('uncache requires 1 args')
        sys.exit(1)
    pp.pprint(client.uncache(eval(args[0]),))

elif cmd == 'repartition':
    if len(args) != 2:
        print('repartition requires 2 args')
        sys.exit(1)
    pp.pprint(client.repartition(eval(args[0]), eval(args[1]),))

elif cmd == 'coalesce':
    if len(args) != 3:
        print('coalesce requires 3 args')
        sys.exit(1)
    pp.pprint(client.coalesce(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'partitions':
    if len(args) != 1:
        print('partitions requires 1 args')
        sys.exit(1)
    pp.pprint(client.partitions(eval(args[0]),))

elif cmd == 'saveAsObjectFile':
    if len(args) != 3:
        print('saveAsObjectFile requires 3 args')
        sys.exit(1)
    pp.pprint(client.saveAsObjectFile(eval(args[0]), args[1], eval(args[2]),))

elif cmd == 'saveAsTextFile':
    if len(args) != 2:
        print('saveAsTextFile requires 2 args')
        sys.exit(1)
    pp.pprint(client.saveAsTextFile(eval(args[0]), args[1],))

elif cmd == 'saveAsJsonFile':
    if len(args) != 3:
        print('saveAsJsonFile requires 3 args')
        sys.exit(1)
    pp.pprint(client.saveAsJsonFile(eval(args[0]), args[1], eval(args[2]),))

elif cmd == 'map_':
    if len(args) != 2:
        print('map_ requires 2 args')
        sys.exit(1)
    pp.pprint(client.map_(eval(args[0]), eval(args[1]),))

elif cmd == 'filter':
    if len(args) != 2:
        print('filter requires 2 args')
        sys.exit(1)
    pp.pprint(client.filter(eval(args[0]), eval(args[1]),))

elif cmd == 'flatmap':
    if len(args) != 2:
        print('flatmap requires 2 args')
        sys.exit(1)
    pp.pprint(client.flatmap(eval(args[0]), eval(args[1]),))

elif cmd == 'mapPartitions':
    if len(args) != 3:
        print('mapPartitions requires 3 args')
        sys.exit(1)
    pp.pprint(client.mapPartitions(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'mapPartitionsWithIndex':
    if len(args) != 3:
        print('mapPartitionsWithIndex requires 3 args')
        sys.exit(1)
    pp.pprint(client.mapPartitionsWithIndex(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'applyPartition':
    if len(args) != 2:
        print('applyPartition requires 2 args')
        sys.exit(1)
    pp.pprint(client.applyPartition(eval(args[0]), eval(args[1]),))

elif cmd == 'groupBy':
    if len(args) != 2:
        print('groupBy requires 2 args')
        sys.exit(1)
    pp.pprint(client.groupBy(eval(args[0]), eval(args[1]),))

elif cmd == 'groupBy2':
    if len(args) != 3:
        print('groupBy2 requires 3 args')
        sys.exit(1)
    pp.pprint(client.groupBy2(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'sort':
    if len(args) != 2:
        print('sort requires 2 args')
        sys.exit(1)
    pp.pprint(client.sort(eval(args[0]), eval(args[1]),))

elif cmd == 'sort2':
    if len(args) != 3:
        print('sort2 requires 3 args')
        sys.exit(1)
    pp.pprint(client.sort2(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'sortBy':
    if len(args) != 3:
        print('sortBy requires 3 args')
        sys.exit(1)
    pp.pprint(client.sortBy(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'sortBy3':
    if len(args) != 4:
        print('sortBy3 requires 4 args')
        sys.exit(1)
    pp.pprint(client.sortBy3(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]),))

elif cmd == 'reduce':
    if len(args) != 3:
        print('reduce requires 3 args')
        sys.exit(1)
    pp.pprint(client.reduce(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'treeReduce':
    if len(args) != 3:
        print('treeReduce requires 3 args')
        sys.exit(1)
    pp.pprint(client.treeReduce(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'treeReduce4':
    if len(args) != 4:
        print('treeReduce4 requires 4 args')
        sys.exit(1)
    pp.pprint(client.treeReduce4(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]),))

elif cmd == 'collect':
    if len(args) != 2:
        print('collect requires 2 args')
        sys.exit(1)
    pp.pprint(client.collect(eval(args[0]), eval(args[1]),))

elif cmd == 'aggregate':
    if len(args) != 4:
        print('aggregate requires 4 args')
        sys.exit(1)
    pp.pprint(client.aggregate(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]),))

elif cmd == 'treeAggregate':
    if len(args) != 4:
        print('treeAggregate requires 4 args')
        sys.exit(1)
    pp.pprint(client.treeAggregate(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]),))

elif cmd == 'treeAggregate5':
    if len(args) != 5:
        print('treeAggregate5 requires 5 args')
        sys.exit(1)
    pp.pprint(client.treeAggregate5(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]), eval(args[4]),))

elif cmd == 'fold':
    if len(args) != 3:
        print('fold requires 3 args')
        sys.exit(1)
    pp.pprint(client.fold(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'take':
    if len(args) != 3:
        print('take requires 3 args')
        sys.exit(1)
    pp.pprint(client.take(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'foreach_':
    if len(args) != 2:
        print('foreach_ requires 2 args')
        sys.exit(1)
    pp.pprint(client.foreach_(eval(args[0]), eval(args[1]),))

elif cmd == 'foreachPartition':
    if len(args) != 2:
        print('foreachPartition requires 2 args')
        sys.exit(1)
    pp.pprint(client.foreachPartition(eval(args[0]), eval(args[1]),))

elif cmd == 'top':
    if len(args) != 3:
        print('top requires 3 args')
        sys.exit(1)
    pp.pprint(client.top(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'top4':
    if len(args) != 4:
        print('top4 requires 4 args')
        sys.exit(1)
    pp.pprint(client.top4(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]),))

elif cmd == 'sample':
    if len(args) != 4:
        print('sample requires 4 args')
        sys.exit(1)
    pp.pprint(client.sample(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]),))

elif cmd == 'takeSample':
    if len(args) != 5:
        print('takeSample requires 5 args')
        sys.exit(1)
    pp.pprint(client.takeSample(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]), eval(args[4]),))

elif cmd == 'count':
    if len(args) != 1:
        print('count requires 1 args')
        sys.exit(1)
    pp.pprint(client.count(eval(args[0]),))

elif cmd == 'max':
    if len(args) != 3:
        print('max requires 3 args')
        sys.exit(1)
    pp.pprint(client.max(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'min':
    if len(args) != 3:
        print('min requires 3 args')
        sys.exit(1)
    pp.pprint(client.min(eval(args[0]), eval(args[1]), eval(args[2]),))

else:
    print('Unrecognized method %s' % cmd)
    sys.exit(1)

transport.close()
