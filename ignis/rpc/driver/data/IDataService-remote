#!/usr/bin/env python
#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

import sys
import pprint
if sys.version_info[0] > 2:
    from urllib.parse import urlparse
else:
    from urlparse import urlparse
from thrift.transport import TTransport, TSocket, TSSLSocket, THttpClient
from thrift.protocol.TBinaryProtocol import TBinaryProtocol

from ignis.rpc.driver.data import IDataService
from ignis.rpc.driver.data.ttypes import *

if len(sys.argv) <= 1 or sys.argv[1] == '--help':
    print('')
    print('Usage: ' + sys.argv[0] + ' [-h host[:port]] [-u url] [-f[ramed]] [-s[sl]] [-novalidate] [-ca_certs certs] [-keyfile keyfile] [-certfile certfile] function [arg1 [arg2...]]')
    print('')
    print('Functions:')
    print('  void setName(IDataId data, string name)')
    print('  IDataId _map(IDataId data, ISource _function)')
    print('  IDataId flatmap(IDataId data, ISource _function)')
    print('  IDataId filter(IDataId data, ISource _function)')
    print('  IDataId keyBy(IDataId data, ISource _function)')
    print('  IDataId streamingMap(IDataId data, ISource _function, bool ordered)')
    print('  IDataId streamingFlatmap(IDataId data, ISource _function, bool ordered)')
    print('  IDataId streamingFilter(IDataId data, ISource _function, bool ordered)')
    print('  IDataId streamingKeyBy(IDataId data, ISource _function, bool ordered)')
    print('  IDataId reduceByKey(IDataId data, ISource _function)')
    print('  IDataId values(IDataId data)')
    print('  IDataId shuffle(IDataId data)')
    print('  IDataId parallelize()')
    print('   take(IDataId data, i64 n, bool light)')
    print('   takeSample(IDataId data, i64 n, bool withRemplacement, i32 seed, bool light)')
    print('   collect(IDataId data, bool light)')
    print('  IDataId sortBy(IDataId data, ISource funct, bool ascending)')
    print('  IDataId sort(IDataId data, bool ascending)')
    print('  void saveAsTextFile(IDataId data, string path, bool join)')
    print('  void saveAsJsonFile(IDataId data, string path, bool join)')
    print('  void cache(IDataId data)')
    print('  void uncache(IDataId data)')
    print('')
    sys.exit(0)

pp = pprint.PrettyPrinter(indent=2)
host = 'localhost'
port = 9090
uri = ''
framed = False
ssl = False
validate = True
ca_certs = None
keyfile = None
certfile = None
http = False
argi = 1

if sys.argv[argi] == '-h':
    parts = sys.argv[argi + 1].split(':')
    host = parts[0]
    if len(parts) > 1:
        port = int(parts[1])
    argi += 2

if sys.argv[argi] == '-u':
    url = urlparse(sys.argv[argi + 1])
    parts = url[1].split(':')
    host = parts[0]
    if len(parts) > 1:
        port = int(parts[1])
    else:
        port = 80
    uri = url[2]
    if url[4]:
        uri += '?%s' % url[4]
    http = True
    argi += 2

if sys.argv[argi] == '-f' or sys.argv[argi] == '-framed':
    framed = True
    argi += 1

if sys.argv[argi] == '-s' or sys.argv[argi] == '-ssl':
    ssl = True
    argi += 1

if sys.argv[argi] == '-novalidate':
    validate = False
    argi += 1

if sys.argv[argi] == '-ca_certs':
    ca_certs = sys.argv[argi+1]
    argi += 2

if sys.argv[argi] == '-keyfile':
    keyfile = sys.argv[argi+1]
    argi += 2

if sys.argv[argi] == '-certfile':
    certfile = sys.argv[argi+1]
    argi += 2

cmd = sys.argv[argi]
args = sys.argv[argi + 1:]

if http:
    transport = THttpClient.THttpClient(host, port, uri)
else:
    if ssl:
        socket = TSSLSocket.TSSLSocket(host, port, validate=validate, ca_certs=ca_certs, keyfile=keyfile, certfile=certfile)
    else:
        socket = TSocket.TSocket(host, port)
    if framed:
        transport = TTransport.TFramedTransport(socket)
    else:
        transport = TTransport.TBufferedTransport(socket)
protocol = TBinaryProtocol(transport)
client = IDataService.Client(protocol)
transport.open()

if cmd == 'setName':
    if len(args) != 2:
        print('setName requires 2 args')
        sys.exit(1)
    pp.pprint(client.setName(eval(args[0]), args[1],))

elif cmd == '_map':
    if len(args) != 2:
        print('_map requires 2 args')
        sys.exit(1)
    pp.pprint(client._map(eval(args[0]), eval(args[1]),))

elif cmd == 'flatmap':
    if len(args) != 2:
        print('flatmap requires 2 args')
        sys.exit(1)
    pp.pprint(client.flatmap(eval(args[0]), eval(args[1]),))

elif cmd == 'filter':
    if len(args) != 2:
        print('filter requires 2 args')
        sys.exit(1)
    pp.pprint(client.filter(eval(args[0]), eval(args[1]),))

elif cmd == 'keyBy':
    if len(args) != 2:
        print('keyBy requires 2 args')
        sys.exit(1)
    pp.pprint(client.keyBy(eval(args[0]), eval(args[1]),))

elif cmd == 'streamingMap':
    if len(args) != 3:
        print('streamingMap requires 3 args')
        sys.exit(1)
    pp.pprint(client.streamingMap(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'streamingFlatmap':
    if len(args) != 3:
        print('streamingFlatmap requires 3 args')
        sys.exit(1)
    pp.pprint(client.streamingFlatmap(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'streamingFilter':
    if len(args) != 3:
        print('streamingFilter requires 3 args')
        sys.exit(1)
    pp.pprint(client.streamingFilter(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'streamingKeyBy':
    if len(args) != 3:
        print('streamingKeyBy requires 3 args')
        sys.exit(1)
    pp.pprint(client.streamingKeyBy(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'reduceByKey':
    if len(args) != 2:
        print('reduceByKey requires 2 args')
        sys.exit(1)
    pp.pprint(client.reduceByKey(eval(args[0]), eval(args[1]),))

elif cmd == 'values':
    if len(args) != 1:
        print('values requires 1 args')
        sys.exit(1)
    pp.pprint(client.values(eval(args[0]),))

elif cmd == 'shuffle':
    if len(args) != 1:
        print('shuffle requires 1 args')
        sys.exit(1)
    pp.pprint(client.shuffle(eval(args[0]),))

elif cmd == 'parallelize':
    if len(args) != 0:
        print('parallelize requires 0 args')
        sys.exit(1)
    pp.pprint(client.parallelize())

elif cmd == 'take':
    if len(args) != 3:
        print('take requires 3 args')
        sys.exit(1)
    pp.pprint(client.take(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'takeSample':
    if len(args) != 5:
        print('takeSample requires 5 args')
        sys.exit(1)
    pp.pprint(client.takeSample(eval(args[0]), eval(args[1]), eval(args[2]), eval(args[3]), eval(args[4]),))

elif cmd == 'collect':
    if len(args) != 2:
        print('collect requires 2 args')
        sys.exit(1)
    pp.pprint(client.collect(eval(args[0]), eval(args[1]),))

elif cmd == 'sortBy':
    if len(args) != 3:
        print('sortBy requires 3 args')
        sys.exit(1)
    pp.pprint(client.sortBy(eval(args[0]), eval(args[1]), eval(args[2]),))

elif cmd == 'sort':
    if len(args) != 2:
        print('sort requires 2 args')
        sys.exit(1)
    pp.pprint(client.sort(eval(args[0]), eval(args[1]),))

elif cmd == 'saveAsTextFile':
    if len(args) != 3:
        print('saveAsTextFile requires 3 args')
        sys.exit(1)
    pp.pprint(client.saveAsTextFile(eval(args[0]), args[1], eval(args[2]),))

elif cmd == 'saveAsJsonFile':
    if len(args) != 3:
        print('saveAsJsonFile requires 3 args')
        sys.exit(1)
    pp.pprint(client.saveAsJsonFile(eval(args[0]), args[1], eval(args[2]),))

elif cmd == 'cache':
    if len(args) != 1:
        print('cache requires 1 args')
        sys.exit(1)
    pp.pprint(client.cache(eval(args[0]),))

elif cmd == 'uncache':
    if len(args) != 1:
        print('uncache requires 1 args')
        sys.exit(1)
    pp.pprint(client.uncache(eval(args[0]),))

else:
    print('Unrecognized method %s' % cmd)
    sys.exit(1)

transport.close()
